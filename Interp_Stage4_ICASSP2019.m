function [yHR,mid_step]=Interp_Stage4_ICASSP2019(yIni,n,W,K,lambda,ITER)
yPre=Image_Extend(yIni,n)-128;
[M,N]=size(yPre);
mid_step=zeros(size(yIni,1),size(yIni,2),ITER);
for iter=1:ITER
    HRPatch_Hat=zeros(n^2,(N-n+1)*(M-n+1),'single');
    HRPatch           =single(im2col(yPre,[n n],'sliding'));    
    HRPatch_Normalized=single(normc(HRPatch));        
parfor ind=1:(M-n+1)*(N-n+1)
       [xx,yy]=ind2sub([M-n+1 N-n+1],ind);
       [x_min,x_max,y_min,y_max]=Border_Return(xx,yy,M,N,n,W);
       [yyy,xxx]=meshgrid(y_min:y_max,x_min:x_max);
       s=(yyy-1)*(M-n+1)+xxx;s=s(:);   
       b=HRPatch(:,ind);
       corr=b.'*HRPatch_Normalized(:,s);
       [dddd,indd]=maxk(corr,4*K); 
       X=HRPatch(:,s(indd));
       Core=X'*X+lambda*diag(dddd(1)./(dddd(1:4*K)+1e-5));
       Y_Patch=X*(Core\(X'*b));
       Y_Patch(Y_Patch>+127)=+127;
       Y_Patch(Y_Patch<-128)=-128;
       HRPatch_Hat(:,ind)=Y_Patch(:);
end
y_Hat=zeros(M,N);
Weight=zeros(M,N);
for ind=1:(M-n+1)*(N-n+1)
        [r,c]=ind2sub([M-n+1 N-n+1],ind);
        patch=reshape(HRPatch_Hat(:,ind),[n n]);
         y_Hat(r:r+n-1,c:c+n-1)= y_Hat(r:r+n-1,c:c+n-1)+patch;
        Weight(r:r+n-1,c:c+n-1)=Weight(r:r+n-1,c:c+n-1)+1;
end
     y_Hat=y_Hat./Weight;
      yPre=y_Hat;      
      t=Image_Crop(yPre,n)+128;      
      t(1:2:end,1:2:end)=yIni(1:2:end,1:2:end); 
      yPre=Image_Extend(t,n)-128;
      mid_step(:,:,iter)=t;    
end
yHR=t;
end    
function im_Crop=Image_Crop(im,L)
% crop the image by L.
[M,N]=size(im);
im_Crop=im(L+1:M-L,L+1:N-L);
end
function im_Extend=Image_Extend(im,L)
% extend the image by L.
[M,N]=size(im);
im_Extend=zeros(M+2*L,N+2*L);
im_Extend(L+1:M+L,L+1:N+L)=im(1:M,1:N);

im_Extend(1:M+2*L,    1:L    )=fliplr(im_Extend(1:M+2*L,L+1:2*L));
im_Extend(1:M+2*L,N+L+1:N+L*2)=fliplr(im_Extend(1:M+2*L,N+1:N+L));

im_Extend(    1:L    ,1:N+2*L)=flipud(im_Extend(L+1:2*L,1:N+2*L));
im_Extend(M+L+1:M+L*2,1:N+2*L)=flipud(im_Extend(M+1:M+L,1:N+2*L));
end
function [x_min,x_max,y_min,y_max]=border_return(xx,yy,M,N,n,W) 
        x_min=xx-W;% W is always even, x_min is always odd.
        x_max=xx+W;
        y_min=yy-W;% W is always even, y_min is always odd.
        y_max=yy+W;
       if  xx-W<=0
           x_min=1;
           x_max=1+2*W;
       end
       if  xx+W>M-n+1
           x_min=M-n+1-2*W;
           x_max=M-n+1;
       end
       if  yy-W<=0
           y_min=1;
           y_max=1+2*W;
       end
       if  yy+W>N-n+1
           y_max=N-n+1;
           y_min=N-n+1-2*W;           
       end
end