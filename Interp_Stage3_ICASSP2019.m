function [yHR,mid_step]=Interp_Stage3_ICASSP2019(yIni,n,W,K,lambda,cw,ITER)
%% Interp_Stage3_ICASSP2019 function updated a interpolated image from 
%% Stage 2.

%% Function Input:
% 1.  yIni: the input grayscale image from Stage 2.
% 2.     n: patchs size: nxn.
% 3.     W: half-window size of the search window, the actual size of 
%           the search window: (2W+1)x(2W+1)
% 4.     K: number of similar patches 
% 5.lambda: the penalty constant for RIDGE regression.
% 6.    cw: the constant for computing the similarity measure [0,1].
% 7.  ITER: the number of iterations.

%% Function output:
% 1. yHR: the interpolated image after Stage 3.
% 2. mid_step: the intermediate images for further inspections.

M=size(yIni,1)+2*n;
N=size(yIni,2)+2*n;
mid_step=zeros(size(yIni,1),size(yIni,2),ITER);
[~,IND_EO,IND_OE,IND_EE]=phase_dsp_2x(n);
% Generate IND_OE,IND_OO,IND_EE and IND_EO given n.

yPre=Image_Extend(yIni,n);
inddd=1:(M/2-n/2+1)*(N/2-n/2+1);
[xx_LR,yy_LR]=ind2sub([M/2-n/2+1 N/2-n/2+1],inddd);
xx=xx_LR*2-1;
yy=yy_LR*2-1;
ind_2x=sub2ind([M-n+1 N-n+1],xx,yy);   
for iter=1:ITER
    MAX_L=ceil((2*W+1)^2/4);
    HRPatch_Hat=zeros(n^2,(N/2-n/2+1)*(M/2-n/2+1),'single');
    HRPatch               =single(im2col(yPre   ,[n n],'sliding'));        
    HRPatch_b_source      =HRPatch(:,ind_2x);   
parfor ind=1:(M/2-n/2+1)*(N/2-n/2+1)
       [xx_LR,yy_LR]=ind2sub([M/2-n/2+1 N/2-n/2+1],ind);
       xx=xx_LR*2-1;
       yy=yy_LR*2-1;
       [x_min,x_max,y_min,y_max]=Border_Return(xx,yy,M,N,n,W);
       Search_Coord_EO=zeros(MAX_L,1,'uint32');
       Search_Coord_OE=zeros(MAX_L,1,'uint32');
       Search_Coord_EE=zeros(MAX_L,1,'uint32');
       [yyy,xxx]=meshgrid(y_min+1:2:y_max,x_min:2:x_max);
       Search_Coord_OE(1:(W+1)*W)=(yyy(:)-1)*(M-n+1)+xxx(:);
       [yyy,xxx]=meshgrid(y_min:2:y_max,x_min+1:2:x_max);
       Search_Coord_EO(1:(W+1)*W)=(yyy(:)-1)*(M-n+1)+xxx(:);
       [yyy,xxx]=meshgrid(y_min+1:2:y_max,x_min+1:2:x_max);
       Search_Coord_EE(1:W^2)    =(yyy(:)-1)*(M-n+1)+xxx(:);
       b   =  HRPatch_b_source(:,ind);      
UPDATE_OE=pixel_return(b,HRPatch,cw,Search_Coord_OE,K,IND_OE,lambda);
UPDATE_EO=pixel_return(b,HRPatch,cw,Search_Coord_EO,K,IND_EO,lambda);
UPDATE_EE=pixel_return(b,HRPatch,cw,Search_Coord_EE,K,IND_EE,lambda);         
      
        Y_OE_HRPatch=zeros(n,n);
        Y_OE_HRPatch(IND_OE)=UPDATE_OE;

        Y_EO_HRPatch=zeros(n,n);        
        Y_EO_HRPatch(IND_EO)=UPDATE_EO;

        Y_EE_HRPatch=zeros(n,n);
        Y_EE_HRPatch(IND_EE)=UPDATE_EE;

        yPatch_Hat=Y_OE_HRPatch+Y_EO_HRPatch+Y_EE_HRPatch;
        yPatch_Hat(yPatch_Hat>+255)=+255;
        yPatch_Hat(yPatch_Hat<   0)=   0;

        HRPatch_Hat(:,ind)=yPatch_Hat(:);
end

y_Hat=zeros(M,N);
Weight=zeros(M,N);
for ind=1:(M/2-n/2+1)*(N/2-n/2+1)
        [xx_LR,yy_LR]=ind2sub([M/2-n/2+1 N/2-n/2+1],ind);
        patch=reshape(HRPatch_Hat(:,ind),[n n]);
        r=xx_LR*2-1;
        c=yy_LR*2-1;
         y_Hat(r:r+n-1,c:c+n-1)= y_Hat(r:r+n-1,c:c+n-1)+patch;
        Weight(r:r+n-1,c:c+n-1)=Weight(r:r+n-1,c:c+n-1)+1;
end
     y_Hat=y_Hat./Weight;
      yPre=y_Hat;      
      t=Image_Crop(yPre,n);      
      t(1:2:end,1:2:end)=yIni(1:2:end,1:2:end); 
      yPre=Image_Extend(t,n);
      mid_step(:,:,iter)=t;            
end
yHR=t;
end  

% Update each patch for each phase, the weights are computed involving 
% all the pixels in a patch.
function UPDATE=pixel_return(b,HRPatch,cw,SearchAreaCoord,K,IND_UPDATE,lambda)
         s=SearchAreaCoord(SearchAreaCoord>0);
           PATCHES=HRPatch(:,s);          
           ddd=-vecnorm(b-PATCHES,1);
           [dddd,ind]=maxk(ddd,K);
           X= PATCHES(:,ind);
           dddd=exp(dddd(1:K)/cw);
           Core=X'*X+lambda*diag(dddd(1)./dddd(:));
           UPDATE=X(IND_UPDATE,:)*(Core\(X'*b));   
end